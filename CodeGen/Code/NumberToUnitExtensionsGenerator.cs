using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace CodeGen;

public static class NumberToUnitExtensionsGenerator
{
    /// <summary>
    /// Generates number-to-unit extension members for all units and all subunit fields.
    /// Ex: doubleValue.Meter => new Length(doubleValue, LengthUnit.Meter)
    /// </summary>
    /// <param name="engineeringUnitsProjectPath">
    /// Path to the EngineeringUnits project folder that contains BaseUnits/ and CombinedUnits/.
    /// (Same style as your existing generators.)
    /// </param>
    public static void Generate(string engineeringUnitsProjectPath)
    {
        // Union base + combined and generate both sets
        GenerateForFolder(engineeringUnitsProjectPath, "BaseUnits",
            ListOfUnitsForDifferentGenerators.GetListOfBaseUnits());

        GenerateForFolder(engineeringUnitsProjectPath, "CombinedUnits",
            ListOfUnitsForDifferentGenerators.GetListOfCombinedUnits());
    }

    private static void GenerateForFolder(string projectPath, string unitRootFolder, IEnumerable<string> unitNames)
    {
        var units = unitNames
            .Where(u => !string.IsNullOrWhiteSpace(u))
            .Distinct(StringComparer.Ordinal)
            .OrderBy(u => u, StringComparer.Ordinal);

        foreach (var unit in units)
        {
            var enumPath = Path.Combine(projectPath, unitRootFolder, unit, $"{unit}Enum.cs");
            if (!File.Exists(enumPath))
            {
                // Skip if the unit enum file is missing (keeps generator resilient)
                continue;
            }

            var subUnits = ExtractStaticReadonlyFieldNames(enumPath, $"{unit}Unit")
                .Where(n => n is not "Unit") // defensive: avoid weird matches
                .Distinct(StringComparer.Ordinal)
                .OrderBy(n => n, StringComparer.Ordinal)
                .ToList();

            if (subUnits.Count == 0)
                continue;

            var content = GenerateFileContent(unit, subUnits);

            var outDir = Path.Combine(projectPath, "NumberExtensions", $"NumberTo{unit}");
            Directory.CreateDirectory(outDir);

            var outFile = Path.Combine(outDir, $"NumberTo{unit}Extensions.cs");
            WriteIfChanged(outFile, content);
        }
    }

    /// <summary>
    /// Extracts all "public static readonly {typeName} Xxx =" field names from the enum file.
    /// Example pattern: public static readonly FrequencyUnit Hertz = ...
    /// </summary>
    private static IEnumerable<string> ExtractStaticReadonlyFieldNames(string enumFilePath, string typeName)
    {
        var text = File.ReadAllText(enumFilePath);

        // Simple, robust-enough regex for your generated enum style:
        // public static readonly FrequencyUnit Hertz = new(...)
        var pattern = $@"public\s+static\s+readonly\s+{Regex.Escape(typeName)}\s+(?<name>[A-Za-z_][A-Za-z0-9_]*)\s*=";
        var matches = Regex.Matches(text, pattern);

        foreach (Match m in matches)
            yield return m.Groups["name"].Value;
    }

    private static string GenerateFileContent(string unit, IReadOnlyList<string> subUnits)
    {
        // Build property bodies
        string DoubleProps() => string.Join(Environment.NewLine,
            subUnits.Select(s => $"        public {unit} {s} => new {unit}(value, {unit}Unit.{s});"));

        string IntProps() => string.Join(Environment.NewLine,
            subUnits.Select(s => $"        public {unit} {s} => new {unit}(value, {unit}Unit.{s});"));

        string DecimalProps() => string.Join(Environment.NewLine,
            subUnits.Select(s => $"        public {unit} {s} => new {unit}((double)value, {unit}Unit.{s});"));

        return $$"""
                 using EngineeringUnits;
                 using EngineeringUnits.Units;

                 namespace EngineeringUnits.NumberExtensions.NumberTo{{unit}};

                 // <auto-generated/>
                 // This file is auto-generated; changes will be overwritten.
                 public static class NumberTo{{unit}}Extensions
                 {
                     // double receiver
                     extension(double value)
                     {
                 {{DoubleProps()}}
                     }

                     // int receiver
                     extension(int value)
                     {
                 {{IntProps()}}
                     }

                     // decimal receiver (convert as needed)
                     extension(decimal value)
                     {
                 {{DecimalProps()}}
                     }
                 }
                 """;
    }

    private static void WriteIfChanged(string path, string content)
    {
        // Small upgrade: don’t rewrite files if content didn’t change (clean diffs, faster CI)
        if (File.Exists(path))
        {
            var existing = File.ReadAllText(path);
            if (string.Equals(existing, content, StringComparison.Ordinal))
                return;
        }

        // Consistent encoding; choose BOM/no-BOM as you prefer
        var utf8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
        File.WriteAllText(path, content, utf8NoBom);
    }
}