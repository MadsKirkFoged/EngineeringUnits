using System.Text;
using System.Reflection;
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace CodeGen.Code;

internal static class GenerateNumberToUnitExtensions
{
    public static void Generate(string projectPath)
    {
        GenerateForFolder(
            projectPath,
            unitRootFolder: "CombinedUnits",
            units: ListOfUnitsForDifferentGenerators.GetListOfCombinedUnits());

        GenerateForFolder(
            projectPath,
            unitRootFolder: "BaseUnits",
            units: ListOfUnitsForDifferentGenerators.GetListOfBaseUnits());
    }

    private static void GenerateForFolder(string projectPath, string unitRootFolder, IEnumerable<string> units)
    {
        var sortedUnits = units
            .Where(u => !string.IsNullOrWhiteSpace(u))
            .Distinct(StringComparer.Ordinal)
            .OrderBy(u => u, StringComparer.Ordinal);

        foreach (var unit in sortedUnits)
        {
            var content = GenerateFile(unit);
            if (content is null)
                continue;

            // ✅ Place inside each unit folder (like your Length test)
            var unitFolder = Path.Combine(projectPath, unitRootFolder, unit);
            Directory.CreateDirectory(unitFolder);

            var filePath = Path.Combine(unitFolder, $"NumberTo{unit}Extensions.cs");
            WriteIfChanged(filePath, content);
        }
    }

    private static string? GenerateFile(string unit)
    {
        // Reflection lookup same style as your GenerateSetter
        var typeName = $"EngineeringUnits.Units.{unit}Unit, EngineeringUnits";
        var t = Type.GetType(typeName);

        if (t is null)
            return null;

        // Only public static fields (the unit definitions)
        var fields = t.GetFields(BindingFlags.Public | BindingFlags.Static)
            // Safety: only fields whose type is the unit type itself
            .Where(f => f.FieldType == t)
            // Requirement: exclude SI
            .Where(f => !string.Equals(f.Name, "SI", StringComparison.Ordinal))
            .Select(f => f.Name)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(n => n, StringComparer.Ordinal)
            .ToList();

        if (fields.Count == 0)
            return null;

        return Template(unit, fields);
    }

    private static string Template(string unit, IReadOnlyList<string> subUnits)
    {
        // Uses constructors that exist on units like Length(double, LengthUnit) and Length(int, LengthUnit) [1](https://github.com/MadsKirkFoged/EngineeringUnits/blob/master/EngineeringUnits/BaseUnits/Length/Length.cs)
        var doubleProps = string.Join(Environment.NewLine,
            subUnits.Select(s => $"        public {unit} {s} => new {unit}(value, {unit}Unit.{s});"));

        var intProps = string.Join(Environment.NewLine,
            subUnits.Select(s => $"        public {unit} {s} => new {unit}(value, {unit}Unit.{s});"));

        var decimalProps = string.Join(Environment.NewLine,
            subUnits.Select(s => $"        public {unit} {s} => new {unit}((double)value, {unit}Unit.{s});"));

        return $$"""
                 using EngineeringUnits;
                 using EngineeringUnits.Units;

                 namespace EngineeringUnits.NumberExtensions.NumberTo{{unit}};

                 // <auto-generated/>
                 // This file is auto-generated; changes will be overwritten.
                 public static class NumberTo{{unit}}Extensions
                 {
                     // double receiver
                     extension(double value)
                     {
                 {{doubleProps}}
                     }

                     // int receiver
                     extension(int value)
                     {
                 {{intProps}}
                     }

                     // decimal receiver (convert as needed)
                     extension(decimal value)
                     {
                 {{decimalProps}}
                     }
                 }
                 """;
    }

    private static void WriteIfChanged(string path, string content)
    {
        if (File.Exists(path))
        {
            var existing = File.ReadAllText(path);
            if (string.Equals(existing, content, StringComparison.Ordinal))
                return;
        }

        var utf8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
        File.WriteAllText(path, content, utf8NoBom);
    }
}